# LangGraph ft. Refraction

Existing agentic frameworks rarely allow API calls directly, but allow access
to tools as described above (which can in turn wrap an API call within).
In a previous chapter, we explored how we can wrap those tools

It turns out that the LangGraph [tool](https://python.langchain.com/docs/concepts/tools)
decorator does not allow an extra wrapper
around it. So you cannot currently use the refraction decorator to invoke a tool
or agent directly. ‚òπÔ∏è üòí üò©

However, you can still use it to call a tool node directly,
or using the stateful formulation of a workflow.

# 8.1 Direct Tool Node Invocation

Consider the following tools: again‚â§ one directly with the input signature of the function
as an API would have been, and the other with a state as input, but with information
in the refraction decorator as to what API it wraps.

```python
@refract(
    api="TripadvisorSearchHotels",
    use_given_operators_only=False,
    execute_if_fixed=True,
    use_state=True,
)
def search_hotels(state: State) -> Dict[str, Any]:
    """Tripadvisor search hotels"""
    return {"response": f"{state.get('geoId')}: hotels", **state}


@refract()
def TripadvisorSearchLocation(query: str) -> str:
    """Tripadvisor search location"""
    return f"{query}: locations"
```

```python
catalog = get_nestful_catalog(executable=True)
refractor = Refractor(catalog)

tools = [search_hotels, TripadvisorSearchLocation]
tool_node = ToolNode(tools)

message_with_single_tool_call = AIMessage(
    content="",
    tool_calls=[
        {
            "name": "TripadvisorSearchLocation",
            "args": {"query": "San Juan", "refractor": refractor},
            "id": "5241421",
            "type": "tool_call",
        }
    ],
)

result = tool_node.invoke({"messages": [message_with_single_tool_call]})
```

**Notice the extra parameter** in `args` (you can also pass in a
memory [like before](02.-The-Refraction-API-|-Inputs-and-Outputs.md#using-a-memory)).
This call will pass without incident because the call is correct.

# 8.2 Calling Inside a Workflow using State

```python
workflow = StateGraph(State)
workflow.add_node("search_hotels_node", search_hotels)

workflow.add_edge(start_key=START, end_key="search_hotels_node")
workflow.add_edge(start_key="search_hotels_node", end_key=END)

chain = workflow.compile()

memory = {"var1": {"geoId": 123}}

state = chain.invoke(
    {
        "checkIn": "...",
        "checkOut": "...",
        "refractor": self.refractor,
        "memory": memory,
    }
)
```

Here, the input for `geoId` is missing both in the input and in memory. The refractor decoration
corrects the call using the memory input, and executes on the fly. üòç

```
  var1 = TripadvisorSearchHotels(geoId="234", checkIn="...", checkOut="...")


- var1 = TripadvisorSearchHotels(checkIn="...", checkOut="...")
+ var1 = TripadvisorSearchHotels(checkIn="...", checkOut="...", geoId="$var1.geoId$")
?                                                             ++++++++++++++++++++++
```

```
Executing: TripadvisorSearchHotels(checkIn="...", checkOut="...", geoId="123")
```
